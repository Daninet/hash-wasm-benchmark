self.webpackChunk([1],{16:function(t,e,r){"use strict";r.r(e),r.d(e,"hash",(function(){return c})),r.d(e,"create_hasher",(function(){return d})),r.d(e,"create_keyed",(function(){return u})),r.d(e,"create_derive",(function(){return p})),r.d(e,"Blake3Hash",(function(){return y})),r.d(e,"HashReader",(function(){return b})),r.d(e,"__wbindgen_throw",(function(){return v}));var n=r(17);let s=new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0});s.decode();let o=null;function i(){return null!==o&&o.buffer===n.o.buffer||(o=new Uint8Array(n.o.buffer)),o}let a=0;function h(t,e){const r=e(1*t.length);return i().set(t,r/1),a=t.length,r}function c(t,e){try{var r=h(t,n.d),s=a,o=h(e,n.d),c=a;n.l(r,s,o,c)}finally{e.set(i().subarray(o/1,o/1+c)),n.c(o,1*c)}}function d(){var t=n.j();return y.__wrap(t)}function u(t){var e=h(t,n.d),r=a,s=n.k(e,r);return y.__wrap(s)}let f=new TextEncoder("utf-8");const l="function"==typeof f.encodeInto?function(t,e){return f.encodeInto(t,e)}:function(t,e){const r=f.encode(t);return e.set(r),{read:t.length,written:r.length}};function p(t){var e=function(t,e,r){if(void 0===r){const r=f.encode(t),n=e(r.length);return i().subarray(n,n+r.length).set(r),a=r.length,n}let n=t.length,s=e(n);const o=i();let h=0;for(;h<n;h++){const e=t.charCodeAt(h);if(e>127)break;o[s+h]=e}if(h!==n){0!==h&&(t=t.slice(h)),s=r(s,n,n=h+3*t.length);const e=i().subarray(s+h,s+n);h+=l(t,e).written}return a=h,s}(t,n.d,n.e),r=a,s=n.i(e,r);return y.__wrap(s)}const w=new Uint32Array(2),g=new BigUint64Array(w.buffer);class y{static __wrap(t){const e=Object.create(y.prototype);return e.ptr=t,e}free(){const t=this.ptr;this.ptr=0,n.a(t)}reader(){var t=n.g(this.ptr);return b.__wrap(t)}update(t){var e=h(t,n.d),r=a;n.h(this.ptr,e,r)}digest(t){try{var e=h(t,n.d),r=a;n.f(this.ptr,e,r)}finally{t.set(i().subarray(e/1,e/1+r)),n.c(e,1*r)}}}class b{static __wrap(t){const e=Object.create(b.prototype);return e.ptr=t,e}free(){const t=this.ptr;this.ptr=0,n.b(t)}fill(t){try{var e=h(t,n.d),r=a;n.m(this.ptr,e,r)}finally{t.set(i().subarray(e/1,e/1+r)),n.c(e,1*r)}}set_position(t){g[0]=t;const e=w[0],r=w[1];n.n(this.ptr,e,r)}}const v=function(t,e){throw new Error((r=t,n=e,s.decode(i().subarray(r,r+n))));var r,n}},17:function(t,e,r){"use strict";var n=r.w[t.i];t.exports=n;r(16);n.p()},18:function(t,e,r){"use strict";let n;r.r(e),r.d(e,"hash",(function(){return p})),r.d(e,"deriveKey",(function(){return w})),r.d(e,"keyedHash",(function(){return g})),r.d(e,"BrowserHasher",(function(){return E})),r.d(e,"createHash",(function(){return B})),r.d(e,"createKeyed",(function(){return x})),r.d(e,"defaultHashLength",(function(){return i})),r.d(e,"inputToArray",(function(){return a})),r.d(e,"maxHashBytes",(function(){return y})),r.d(e,"BaseHashReader",(function(){return b})),r.d(e,"BaseHash",(function(){return v})),r.d(e,"using",(function(){return _}));const s=()=>{if(!n)throw new Error("BLAKE3 webassembly not loaded. Please import the module via `blake3/browser` or `blake3/browser-async`");return n};var o=r(16);const i=32,a=t=>t instanceof Uint8Array?t:new Uint8Array(t),h=new TextDecoder,c={base64:t=>btoa(String.fromCharCode(...t)),hex:t=>{let e="";for(const r of t)r<16&&(e+="0"),e+=r.toString(16);return e},utf8:t=>h.decode(t)},d=t=>{const e=c[t];if(!e)throw new Error("Unknown encoding "+t);return e};class u extends Uint8Array{equals(t){if(!(t instanceof Uint8Array))return!1;if(t.length!==this.length)return!1;let e=0;for(let r=0;r<this.length;r++)e|=this[r]^t[r];return 0===e}toString(t="hex"){return d(t)(this)}}const f=new TextEncoder,l=t=>a("string"==typeof t?f.encode(t):t);function p(t,{length:e=i}={}){const r=new u(e);return s().hash(l(t),r),r}function w(t,e,{length:r=i}={}){const n=s().create_derive(t);n.update(l(e));const o=new u(r);return n.digest(o),o}function g(t,e,{length:r=i}={}){if(32!==t.length)throw new Error("key provided to keyedHash must be 32 bytes, got "+t.length);const n=s().create_keyed(t);n.update(l(e));const o=new u(r);return n.digest(o),o}const y=BigInt("18446744073709551615");class b{constructor(t){this.pos=BigInt(0),this.reader=t}get position(){return this.pos}set position(t){var e;if("bigint"!=typeof t)throw new Error(`Got a ${typeof t} set in to reader.position, expected a bigint`);this.boundsCheck(t),this.pos=t,null===(e=this.reader)||void 0===e||e.set_position(t)}readInto(t){if(!this.reader)throw new Error("Cannot read from a hash after it was disposed");const e=this.pos+BigInt(t.length);this.boundsCheck(e),this.reader.fill(t),this.position=e}read(t){const e=this.alloc(t);return this.readInto(e),e}dispose(){var t,e;null===(e=null===(t=this.reader)||void 0===t?void 0:t.free)||void 0===e||e.call(t),this.reader=void 0}boundsCheck(t){if(t>y)throw new RangeError(`Cannot read past ${y} bytes in BLAKE3 hashes`);if(t<BigInt(0))throw new RangeError("Cannot read to a negative position")}}class v{constructor(t,e,r){this.alloc=e,this.getReader=r,this.hash=t}update(t){if(!this.hash)throw new Error("Cannot continue updating hashing after dispose() has been called");return this.hash.update(a(t)),this}digest({length:t=i,dispose:e=!0}={}){if(!this.hash)throw new Error("Cannot call digest() after dipose() has been called");const r=this.alloc(t);return this.hash.digest(r),e&&this.dispose(),r}reader({dispose:t=!0}={}){if(!this.hash)throw new Error("Cannot call reader() after dipose() has been called");const e=this.getReader(this.hash.reader());return t&&this.dispose(),e}dispose(){var t;null===(t=this.hash)||void 0===t||t.free(),this.hash=void 0}}const _=(t,e)=>{let r;try{r=e(t)}catch(e){throw t.dispose(),e}return"object"==typeof(n=r)&&n&&"then"in n?r.then(e=>(t.dispose(),e),e=>{throw t.dispose(),e}):(t.dispose(),r);var n};class k extends b{toString(t="hex"){return this.toArray().toString(t)}toArray(){return this.position=BigInt(0),this.read(i)}alloc(t){return new u(t)}}class E extends v{update(t){return super.update(l(t))}digest(t,e){let r,n;t&&"object"==typeof t?(r=t,n=void 0):(r=e,n=t);const s=super.digest(r);return n?d(n)(s):s}}const B=()=>new E(s().create_hasher(),t=>new u(t),t=>new k(t)),x=t=>new E(s().create_keyed(t),t=>new u(t),t=>new k(t));n=o}});